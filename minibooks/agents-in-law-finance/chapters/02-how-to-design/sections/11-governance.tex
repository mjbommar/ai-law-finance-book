% ============================================================================
% 11-governance.tex
% Q10: How Do We Design Systems That Can Be Governed?
% Part of: Chapter 2 - How to Design an Agent
% ============================================================================

\section{How Do We Design Systems That Can Be Governed?}
\label{sec:agents2-governance}

% ----------------------------------------------------------------------------
% Opening: Architecture Enables Governance
% ----------------------------------------------------------------------------

You cannot audit what you did not log. You cannot enforce privilege boundaries that were never implemented. You cannot override a system that lacks pause mechanisms. When a regulator asks how the compliance agent detected a breach, or when opposing counsel demands the agent's reasoning, architecture determines whether you can answer.

This distinction matters: \textit{governance policy} defines what controls are required; \textit{governance-aware architecture} provides the technical foundation that makes those controls possible. Chapter~3 (\textit{How to Govern an Agent}) addresses policy---the five-layer regulatory framework, dimensional calibration, and organizational accountability. This section addresses architecture: the patterns that enable governance, drawn from the capabilities developed throughout this chapter.

\begin{keybox}[title={Architecture Before Policy}]
Governance cannot be retrofittedâ€”systems designed without audit logging cannot suddenly produce compliance reports when regulators arrive, those lacking approval gates cannot enforce human-in-the-loop oversight after deployment, and architectures missing state snapshots cannot support rollback or investigation when failures occur. The architectural decisions in this chapter are not merely technical choices; they are the infrastructure that makes governance possible.
\end{keybox}

Five architectural patterns support governance: logging, override mechanisms, state management, privilege enforcement, and escalation hooks. Each pattern draws on capabilities introduced in earlier sections; this section synthesizes them into a coherent governance foundation.

% ----------------------------------------------------------------------------
% Logging Architecture
% ----------------------------------------------------------------------------

\subsection{Logging Architecture}
\label{sec:agents2-logging-arch}

Comprehensive logging is the foundation of all governance. Without logs, there is no audit trail, no incident investigation, no compliance demonstration, and no accountability. Every architectural component in this chapter generates events that must be captured.

\textbf{Trigger logs} record what initiated each agent activation (\Cref{sec:agents2-triggers}). The five evaluation criteria for triggers---coverage, latency, reliability, priority, and \textit{auditability}---require that every trigger event be logged with its source, timestamp, and routing decision. When a regulatory filing triggers a compliance review, the log must capture which filing, when it arrived, and why it was routed to that particular workflow.

\textbf{Intent logs} capture how the agent understood what was asked (\Cref{sec:agents2-intent}). Goal extraction, constraint identification, and any clarification interactions must be logged to reconstruct what the agent believed it was trying to accomplish. When results are challenged, intent logs reveal whether the agent misunderstood the request, extracted incorrect constraints, or correctly understood but failed in execution.

\textbf{Perception logs} record what information the agent accessed (\Cref{sec:agents2-perception-eval}). Every database query, document retrieval, and API call must be logged with parameters and results. For regulated applications, you must be able to reconstruct what information the agent considered when making a decision. If the agent reviewed ten documents but cited only three, the perception log should show all ten.

\textbf{Reasoning traces} capture how the agent planned and reasoned (\Cref{sec:agents2-planning-patterns}). ReAct-style patterns explicitly generate thought-action-observation sequences; these traces make decisions transparent and auditable. For dynamic orchestration, where the agent selects decomposition strategies at runtime, logs must capture the \textit{reasoning} behind orchestration decisions, not just the decisions themselves.

\textbf{Action logs} record what the agent did (\Cref{sec:agents2-action}). Every action must be logged with the agent identity, timestamp, parameters, and matter/client context. Action logs allow reconstruction: given a complaint about an erroneous filing, you can trace back through the action log to find when it was filed, what parameters were used, and what reasoning preceded it.

\textbf{Memory access logs} track reads and writes to persistent state (\Cref{sec:agents2-memory}). Each operation should be logged with a timestamp, the requesting agent or user, and the matter identifier. These logs support compliance review, breach investigation, and documentation that appropriate controls were maintained.

\textbf{Delegation logs} capture agent-to-agent interactions (\Cref{sec:agents2-delegation}). When a coordinator delegates to specialists, the log must record the delegation contract, the specialist's identity, and the returned artifacts. Complete delegation logging supports audit trails that span the entire delegation tree.

\begin{practicebox}[title={Structured Logging Schema}]
Effective governance requires structured logs, not free-form text. A minimal schema includes:
\begin{itemize}[nosep]
\item \textbf{Timestamp}: ISO 8601 with timezone
\item \textbf{Event type}: trigger, perception, reasoning, action, memory, delegation
\item \textbf{Agent identity}: which agent or component generated the event
\item \textbf{Matter/client context}: isolation identifier for multi-tenant systems
\item \textbf{Parameters}: structured data specific to the event type
\item \textbf{Outcome}: success, failure, or pending
\end{itemize}
Structured logs facilitate programmatic analysis, anomaly detection, and automated compliance reporting.
\end{practicebox}

% ----------------------------------------------------------------------------
% Override and Circuit Breaker Patterns
% ----------------------------------------------------------------------------

\subsection{Override and Circuit Breaker Patterns}
\label{sec:agents2-override-patterns}

Governance requires the ability to intervene. Humans must be able to pause, redirect, or stop agent execution at any point. Three patterns provide this capability.

\textbf{Circuit breakers} automatically halt execution when anomalies are detected (\Cref{sec:agents2-circuit-breakers}). These include failure count thresholds (e.g., stop after three consecutive failures), spike detection (e.g., pause if action rate exceeds 5$\times$ baseline), and error rate monitoring. Circuit breakers transform runaway failures into controlled pauses, buying time for human intervention. The key architectural requirement is that circuit breaker state must be external to the agent---an agent cannot be trusted to halt itself reliably.

\textbf{Step limits} provide hard backstops (\Cref{sec:agents2-termination}, specifically \Cref{sec:agents2-loop-detection}). Regardless of other conditions, after $N$ total steps the agent must stop and require human approval before continuing. This prevents unbounded execution even when other detection mechanisms fail. The appropriate limit depends on the task, but the key is that \textit{some} limit exists and is enforced by the orchestration layer, not by the agent itself.

\textbf{Manual override interfaces} allow humans to intervene at any time. This requires:
\begin{itemize}[nosep]
\item \textbf{Pause}: Suspend execution while preserving state, allowing inspection before resumption.
\item \textbf{Abort}: Terminate execution immediately, triggering graceful degradation (\Cref{sec:agents2-graceful-degradation}) to preserve partial work.
\item \textbf{Redirect}: Modify the agent's goal or constraints mid-execution without losing accumulated context.
\end{itemize}

These interfaces must be accessible to authorized personnel regardless of the agent's internal state. An agent stuck in a loop or processing a high-volume task must still respond to override commands. This typically requires a separate control plane---a monitoring service that can signal the agent through a channel the agent cannot ignore.

\begin{keybox}[title={The Red Button Problem}]
Every production agentic system needs an emergency stop mechanism---the ``red button'' that immediately halts all agent activity. This is not merely a graceful shutdown request; it is an immediate cessation of all external actions. Implementing this requires that action tools check a global halt flag before execution, that the halt flag is stored externally (not in agent memory), and that the flag can be set through an out-of-band channel that bypasses normal request processing.
\end{keybox}

% ----------------------------------------------------------------------------
% State Snapshots and Checkpoints
% ----------------------------------------------------------------------------

\subsection{State Snapshots and Checkpoints}
\label{sec:agents2-state-snapshots}

Three governance requirements depend on state management: reproducibility (reconstructing what happened), rollback (undoing problematic changes), and resumability (continuing after interruption).

\textbf{Reproducibility} requires capturing sufficient state to replay decisions. When a regulator asks why the agent made a particular recommendation, you must be able to reconstruct the agent's context at that moment: what was in memory, what had been retrieved, what reasoning had occurred. This is more demanding than simple logging---it requires periodic state snapshots that capture the complete agent context, not just individual events.

\textbf{Rollback capability} supports recovery from errors (\Cref{sec:agents2-reversibility}). For reversible actions, rollback is straightforward: delete the draft, revert the database change. For partially reversible actions, checkpoints allow recovery to the last known good state. The architecture must classify actions by reversibility and maintain appropriate checkpoints for recovery.

\textbf{Checkpoint reviews} support human-in-the-loop oversight (\Cref{sec:agents2-hitl}). At natural milestones within longer workflows, the agent can present its current state and proposed next steps for human validation. These checkpoints prevent the agent from investing significant effort in a wrong direction. Architecturally, checkpoints require the ability to serialize agent state, present it in human-readable form, and resume from exactly that point after approval.

\textbf{Graceful degradation} preserves value when execution terminates early (\Cref{sec:agents2-graceful-degradation}). Whether due to budget exhaustion, confidence drops, or manual abort, the agent should deliver whatever value it has accumulated. This requires maintaining partial results throughout execution, not just at the end. If interrupted after reviewing fifty of one hundred documents, the agent should be able to report findings from the fifty it completed.

Memory state deserves special attention (\Cref{sec:agents2-memory}). When behavior depends on accumulated memory, audit trails must capture not just inputs and outputs but the memory state at key decision points. Which version of the agent produced this output? What was in its memory at the time? Without memory snapshots, accountability for adaptive agents becomes impossible.

% ----------------------------------------------------------------------------
% Least Privilege Enforcement
% ----------------------------------------------------------------------------

\subsection{Least Privilege Enforcement}
\label{sec:agents2-least-privilege}

Least privilege---granting only the minimum permissions required for a task---limits blast radius when things go wrong. This principle appears throughout the chapter; governance-aware architecture enforces it systematically.

\textbf{Tool-level permissions} control what actions an agent can take (\Cref{sec:agents2-action-security}). Role-based access control (RBAC) restricts which agents can invoke which tools. A research agent should not have filing permissions; a filing agent should not have broad database access. The MCP architecture supports this through tool manifests that declare required permissions, allowing the host to enforce access control.

\textbf{Resource-level permissions} control what data an agent can access (\Cref{sec:agents2-mcp-perception}). MCP Resources are explicitly read-only, separating perception from action. An agent with resource access can retrieve documents but cannot modify or file them. This separation supports fine-grained access control that mirrors how organizations already think about permissions.

\textbf{Namespace isolation} enforces boundaries in memory systems (\Cref{sec:agents2-memory-isolation}). Matter isolation ensures that information from one client engagement cannot leak into another. Role-based permissions determine which agents can access each namespace. These controls mirror the ethical wall policies that law firms and financial institutions maintain for human professionals.

\textbf{Multi-agent isolation} uses architectural boundaries to enforce privilege separation (\Cref{sec:agents2-why-multi-agent}). Rather than giving one agent broad permissions, decompose work across specialists, each with narrow permissions. A research agent can read legal databases but cannot file documents; a filing agent can submit to CM/ECF but cannot access client financial data. If one agent is compromised, damage is contained.

\begin{tcolorbox}[
  enhanced,
  colback=bg-caution,
  colframe=caution-base,
  coltitle=white,
  fonttitle=\bfseries,
  title={Privilege Escalation via Tool Chaining},
  boxrule=1.5pt,
  left=3mm,
  right=3mm,
  top=2mm,
  bottom=2mm
]
A sophisticated threat involves combining multiple low-privilege tools to achieve a high-privilege outcome (\Cref{sec:agents2-action-security}). An agent with ``read email'' and ``send email'' permissions might forward confidential information to an external address. Mitigation requires analyzing tool combinations, not just individual tools, and requiring approval for sequences that cross security boundaries.
\end{tcolorbox}

% ----------------------------------------------------------------------------
% Escalation Hooks
% ----------------------------------------------------------------------------

\subsection{Escalation Hooks}
\label{sec:agents2-escalation-hooks}

Escalation transfers control from agent to human when autonomous execution should stop (\Cref{sec:agents2-escalation}). Governance-aware architecture must define clear escalation interfaces that trigger reliably under specified conditions.

\textbf{Confidence-based escalation} triggers when the agent's uncertainty exceeds acceptable thresholds (\Cref{sec:agents2-when-escalate}). The architecture must support confidence estimation and threshold configuration. Different tasks may require different thresholds: a routine lookup tolerates higher uncertainty than a regulatory filing.

\textbf{Authority-based escalation} triggers when a proposed action exceeds the agent's delegated authority. Binding commitments, expenditures above a threshold, or communications with external parties may all require human approval. The architecture must support authority boundaries that can be configured per agent, per task, or per action type.

\textbf{Budget-based escalation} triggers when resource consumption approaches limits (\Cref{sec:agents2-budgets}). Rather than simply halting at budget exhaustion, the agent can escalate when 80\% of budget is consumed, giving humans the opportunity to extend resources or redirect effort. This requires the budget monitoring system to support threshold alerts, not just hard limits.

\textbf{Anomaly-based escalation} triggers when the agent detects unusual patterns---repeated failures, unexpected results, or behavior outside historical norms. This complements circuit breakers: where circuit breakers halt execution, anomaly escalation requests human judgment about whether to continue.

For all escalation types, the architecture must ensure that escalation requests reach humans reliably. An agent that escalates to an unmonitored queue has not meaningfully escalated. Escalation routing, notification, and tracking are architectural requirements, not operational afterthoughts.

% ----------------------------------------------------------------------------
% The Governance Surface
% ----------------------------------------------------------------------------

\subsection{The Governance Surface}
\label{sec:agents2-governance-surface}

\glsadd{governance-surface}
Together, these five patterns define the \keyterm{governance surface}---the interface through which governance systems interact with the agent. Table~\ref{tab:agents2-governance-surface} summarizes the architectural requirements.

\begin{table}[htbp]
\centering
\caption{Governance surface requirements by capability}
\label{tab:agents2-governance-surface}
\small
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Capability} & \textbf{Requirement} \\
\midrule
Logging & Structured events from every component \\
Override & Pause, abort, and redirect controls \\
State Management & Checkpoints with rollback support \\
Least Privilege & RBAC at tool, resource, and namespace levels \\
Escalation Hooks & Configurable triggers with reliable routing \\
\bottomrule
\end{tabular}
\end{table}

This governance surface is what Chapter~3 (\textit{How to Govern an Agent}) builds upon. The five-layer regulatory framework (foundational law, professional obligations, sector regulation, AI-specific regulation, voluntary frameworks) imposes requirements; the governance surface provides the technical means to satisfy them. Without logging, there is no audit trail for regulators. Without override capability, there is no human oversight mechanism. Without state management, there is no reproducibility for investigations. Without least privilege, there is no containment of failures. Without escalation hooks, there is no transfer of control to humans.

The architectural decisions made throughout this chapter---how you design triggers, intent extraction, perception tools, action controls, memory systems, planning mechanisms, termination conditions, escalation protocols, and delegation patterns---collectively determine whether your system can be governed. This section has addressed \textit{how} architecture supports governance; Chapter~3 (\textit{How to Govern an Agent}) addresses \textit{what} governance demands and how to calibrate controls to your specific context and risk profile.
